JS原声Date类型方法的一些冷知识
===========================

由于`Date()`是JS原生函数，不同浏览器的解析器对其实现方式并不同，所以返回值也会有所区别。本文测试未特别申明浏览器的情况下，均是指`win7 x64` + `chrome 44.0.2403.155(正式版) m (32位)`版本。

## Date与new Date的区别

`Date()`直接返回当前时间字符串，**不管参数是number还是string**

```js

Date();
Date('sssss');
Date(1000);
//Fri Aug 21 2015 15:46:21 GMT+0800 (中国标准时间)

```

而`new Date()`则是会根据参数来返回对应的值，无参数的时候，返回当前时间的字符串形式；有参数的时候返回参数所对应时间的字符串。`new Date()`对参数不管是格式还是内容都要求，且只返回字符串。

```js

new Date();
//Fri Aug 21 2015 15:51:55 GMT+0800 (中国标准时间)

new Date(1293879600000);
new Date('2011-01-01T11:00:00')
new Date('2011/01/01 11:00:00')
new Date(2011,0,1,11,0,0)
new Date('jan 01 2011,11 11:00:00')
new Date('Sat Jan 01 2011 11:00:00')
//Sat Jan 01 2011 11:00:00 GMT+0800 (中国标准时间)

new Date('sss');
new Date('2011/01/01T11:00:00');
new Date('2011-01-01-11:00:00')
new Date('1293879600000');
//Invalid Date

new Date('2011-01-01T11:00:00')-new Date('1992/02/11 12:00:12')
//596069988000

```

从上面的几个测试结果可以很容易发现：

1.	`new Date()`在参数正常的情况只会返回当前时间的字符串（且是当前时区的时间）
2.	`new Date()`在解析一个具体的时间的时候，对参数有较严格的格式要求，格式不正确的时候会直接返回`Invalid Date`，比如将`number`类的时间戳转换成`string`类的时候会导致解析出错
3.	虽然`new Date()`的返回值是字符串，然而两个`new Date()`的结果字符串是可以直接相减的，结果为结果为毫秒数。

那么，`new Date()`能接受的参数格式到底是什么标准呢？（相对于严格的多参数传方法。非严格的单参数（数字日期表示格式）更常用且更容易出错，所以下文只考虑单参数数字时间字符串转换的情况）

## new Date()解析所有支持的参数格式标准

### 时间戳格式

这个是最简单的也是最容易出错的。当然唯一的缺点大概就是对开发者不直观，无法一眼就看出具体日期。需要注意的一下两点：

> 1. js内的时间戳是指当前时间到`1970年1月1日00:00:00 UTC`对应的**毫秒数**，和unix时间戳不是一个概念，后者表示描述，差了1000倍
> 2. `new Date(timestamp)`中的时间戳必须是`number`格式，`string`会返回`Inalid Date`。所以比如`new Date('1111111')`这种写法是错误的

### 时间数字字符串格式

不大清楚这种改怎么描述，就是类似`YYYY/MM/DD HH:mm:ss`这种。下文以`dateString`代指。`new Date(dateString)`所支持的字符串格式需要满足[RFC2822标准](http://tools.ietf.org/html/rfc2822#page-14)或者[ISO 8601标准](http://www.w3.org/TR/NOTE-datetime)这两种标准对应的格式分别如下：

1.	RFC2822标准日起字符串

```js

YYYY/MM/DD HH:MM:SS ± timezon(时区用4位数字表示)
// eg 1992/02/12 12:23:22+0800

```

> RFC2822还有别的格式，不过上面这个是比较常用的（另外这个标准实在太难啃，实在没耐心啃完，所以也就没太深入）。RFC2822标准本身还有其他的非数字日起表达个事，不过不在这个话题讨论范围内，略过。

2.	ISO 8601标准日起字符串

```js

 YYYY-MM-DDThh:mm:ss ± timezone(时区用HH:MM表示)

 1997-07-16T08:20:30Z
 // “Z”表示UTC标准时区，即"00:00",所以这里表示零时区的`1997年7月16日08时20分30秒`
 //转换成位于东八区的北京时间则为`1997年7月17日16时20分30秒`

 1997-07-16T19:20:30+01:00
 // 表示东一区的1997年7月16日19时20秒30分，转换成UTC标准时间的话是1997-07-16T18:20:30Z

```

> 1. 日期和事件中间的`T`不可以省略，一省略就出错
> 2. 虽然在chrome浏览器上失去也可以用`+0100`这种RFC2822形式，然而IE上不支持这种混搭写法，所以用ISO8601标准形式表示的时候时区要用`+HH:MM`

淡淡从个事上来说，两者的区别主要在分隔符的不同。不过需要注意的是，ISO8601标准的兼容性比RFC2822差很多（比如IE8和ios均不支持前者）。所以一般情况下建议用`RFC2822`格式的。

不过需要注意的是，在未指定时区的前提下，对于只精确带`day`的日起字符串，`RFC2822`返回结果是以`当前时区的零点`为准，而`iso8601`返回结果则会以`UTC时间`的零点为标准进行解析。

例如：

```js

//RFC2822：
new Date('1992/02/13') //Thu Feb 13 1992 00:00:00 GMT+0800 (中国标准时间)
//ISO8601:
new Date('1992-02-13') //Thu Feb 13 1992 08:00:00 GMT+0800 (中国标准时间)

```

然而上面这个只是ES5的标准而已，在ES6里这两种形式都会变成`当前时区的零点`为基准。

关于跨浏览器的dataString解析情况，还可以参考这个页面：[http://dygraphs.com/date-formats.html](http://dygraphs.com/date-formats.html)

**所以对于时间字符串对象，个人意见是要么用`RFC2822`形式，要么字节写个解析函数然后随便你传啥格式进来**


未完待续....[1234](https://segmentfault.com/a/1190000003710954)